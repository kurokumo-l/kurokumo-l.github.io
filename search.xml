<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>c++中的复制语义和移动语义</title>
      <link href="/2023/11/10/c-%E4%B8%AD%E7%9A%84%E5%A4%8D%E5%88%B6%E8%AF%AD%E4%B9%89%E5%92%8C%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/"/>
      <url>/2023/11/10/c-%E4%B8%AD%E7%9A%84%E5%A4%8D%E5%88%B6%E8%AF%AD%E4%B9%89%E5%92%8C%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/</url>
      
        <content type="html"><![CDATA[<h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><h3 id="复制带来的问题"><a href="#复制带来的问题" class="headerlink" title="复制带来的问题"></a>复制带来的问题</h3><p>默认情况下，我们可以复制一个对象，而复制的默认含义是逐成员的复制，在一些情况下这没什么问题。但是当对象的数据成员包括指针时，也就是说这个对象通过指针访问另一个对象，在这种情况下，默认的复制生成的对象和原对象访问的是同一个对象。</p><p>这会产生很多问题，比如当原对象修改其所管理对象时，复制体中所管理的对象也会被修改。更严重的，当原对象被销毁时，释放掉了其数据成员中的指针所指向的内存，那么复制体中的指针成员就指向了一片已经被释放的内存。</p><p>为了解决上述问题，我们就需要复制构造函数和复制赋值操作符，下面以一个简陋的二维向量作为例子。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Vector</span>() : <span class="built_in">size</span>(<span class="number">1</span>), <span class="built_in">elems</span>(<span class="keyword">new</span> <span class="type">double</span>[<span class="number">1</span>]())</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;DefaultCostructor\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Vector</span>(std::initializer_list&lt;<span class="type">double</span>&gt; initList) : <span class="built_in">size</span>(initList.<span class="built_in">size</span>()), <span class="built_in">elems</span>(<span class="keyword">new</span> <span class="type">double</span>[initList.<span class="built_in">size</span>()]())</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;NormalCostructor\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 复制构造</span></span><br><span class="line">    <span class="built_in">Vector</span>(<span class="type">const</span> Vector &amp;other) : <span class="built_in">size</span>(other.size), <span class="built_in">elems</span>(<span class="keyword">new</span> <span class="type">double</span>[other.size]())</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;CopyCostructor\n&quot;</span>;</span><br><span class="line">        std::<span class="built_in">copy</span>(elems, elems + other.size, other.elems);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 复制赋值</span></span><br><span class="line">    Vector &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Vector &amp;other)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (&amp;other == <span class="keyword">this</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Copy\n&quot;</span>;</span><br><span class="line">        size = other.size;</span><br><span class="line">        <span class="keyword">delete</span>[] elems;</span><br><span class="line">        elems = <span class="keyword">new</span> <span class="type">double</span>[other.size]();</span><br><span class="line">        std::<span class="built_in">copy</span>(elems, elems + other.size, other.elems);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Vector</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Destructor\n&quot;</span>;</span><br><span class="line">        <span class="keyword">delete</span>[] elems;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> size&#123;&#125;;</span><br><span class="line">    <span class="type">double</span> *elems&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在复制构造函数中，我们开辟了一块新的内存，并将<code>other</code>中的<code>elems</code>中的数据复制下来。复制赋值操作符略有不同，由于对象已经拥有数据，所以我们需要先释放掉原有的<code>elems</code>。</p><h3 id="复制开销"><a href="#复制开销" class="headerlink" title="复制开销"></a>复制开销</h3><p>当对象很大时，复制的开销可能相当大，有些时候这无法避免，但很多时候我们并不希望发生复制行为。比如下面这个例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vector <span class="title">Sort</span><span class="params">(<span class="type">const</span> Vector&amp; vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Vector sorted_vec = vec;</span><br><span class="line">    <span class="comment">// sort code</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> sorted_vec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个函数中，我们首先使用<code>vec</code>复制构造了一个<code>sorted_vec</code>，对其完成排序操作后，将其返回。这就会出现一个问题，直觉上来说，想要将<code>sorted_vec</code>传递到外部，就需要将其复制一份，但是这显然相当不合理。因为函数内部的<code>sorted_vec</code>在复制完之后就不会再被使用了，我们理应可以直接将其所持有的资源拿过来，而不需要复制。</p><h3 id="省略复制优化"><a href="#省略复制优化" class="headerlink" title="省略复制优化"></a>省略复制优化</h3><p>事实上编译器经常可以对此进行优化，比如下面这个例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Vector vec1&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    Vector vec2 = <span class="built_in">Sort</span>(vec1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// NormalCostructor</span></span><br><span class="line"><span class="comment">// CopyCostructor</span></span><br><span class="line"><span class="comment">// Destructor</span></span><br><span class="line"><span class="comment">// Destructor</span></span><br></pre></td></tr></table></figure><p><code>vec1</code>的构造输出了”NormalCostructor”，在<code>Sort</code>的内部<code>sorted_vec</code>的复制构造输出了”CopyCostructor”，这里似乎并没有构造<code>vec2</code>？再看看：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vector <span class="title">Sort</span><span class="params">(<span class="type">const</span> Vector&amp; vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Vector sorted_vec = vec;</span><br><span class="line">    <span class="comment">// sort code</span></span><br><span class="line">    std::cout &lt;&lt; &amp;sorted_vec &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> sorted_vec;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Vector vec1&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    Vector vec2 = <span class="built_in">Sort</span>(vec1);</span><br><span class="line">    std::cout &lt;&lt; &amp;vec2 &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// NormalCostructor</span></span><br><span class="line"><span class="comment">// CopyCostructor</span></span><br><span class="line"><span class="comment">// 0000005379AFF798</span></span><br><span class="line"><span class="comment">// 0000005379AFF798</span></span><br><span class="line"><span class="comment">// Destructor</span></span><br><span class="line"><span class="comment">// Destructor</span></span><br></pre></td></tr></table></figure><p>没错，他们的地址是同一个，也就是说<code>vec2</code>和<code>sorted_vec</code>本就是同一个对象，编译器将这次复制给优化掉了。</p><p>那假使是在赋值的情况下呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Vector vec1&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    Vector vec2&#123;&#125;;</span><br><span class="line">    vec2 = <span class="built_in">Sort</span>(vec1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// NormalCostructor</span></span><br><span class="line"><span class="comment">// DefaultCostructor</span></span><br><span class="line"><span class="comment">// CopyCostructor</span></span><br><span class="line"><span class="comment">// Copy</span></span><br><span class="line"><span class="comment">// Destructor</span></span><br><span class="line"><span class="comment">// Destructor</span></span><br><span class="line"><span class="comment">// Destructor</span></span><br></pre></td></tr></table></figure><p>很明显发生了复制，编译器没有为我们优化，但是我们依旧希望有一种办法可以之后拿走<code>sorted_vec</code>给<code>vec2</code>而不要复制。 为此，我们可以给对象提供移动构造方法以及移动赋值操作符。</p><h2 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h2><h3 id="移动构造函数和移动赋值操作符"><a href="#移动构造函数和移动赋值操作符" class="headerlink" title="移动构造函数和移动赋值操作符"></a>移动构造函数和移动赋值操作符</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 移动构造</span></span><br><span class="line">    <span class="built_in">Vector</span>(Vector &amp;&amp;other) <span class="keyword">noexcept</span> : <span class="built_in">size</span>(other.size), <span class="built_in">elems</span>(other.elems)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;MoveCostructor\n&quot;</span>;</span><br><span class="line">        other.elems = <span class="literal">nullptr</span>;</span><br><span class="line">        other.size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 移动赋值</span></span><br><span class="line">    Vector &amp;<span class="keyword">operator</span>=(Vector &amp;&amp;other) <span class="keyword">noexcept</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Move\n&quot;</span>;</span><br><span class="line">        size = other.size;</span><br><span class="line">        <span class="keyword">delete</span>[] elems;</span><br><span class="line">        elems = other.elems;</span><br><span class="line">        other.elems = <span class="literal">nullptr</span>;</span><br><span class="line">        other.size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到，移动构造函数和移动赋值操作符的参数都是<code>Vector &amp;&amp;</code>类型，这在C++中代表右值。简略的说，左值是可以出现在赋值号左边的值，右值则是只能在赋值号右边的值，也就是说，我们没办法操作一个右值，所以拿走一个右值的资源通常上是安全的。</p><p>在移动的过程中，我们释放掉了原有的<code>elems</code>，并直接拿走了<code>other</code>的<code>elems</code>。</p><p>修改<code>Vector</code>后，再回到上面的那个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Vector vec1&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    Vector vec2 = <span class="built_in">Sort</span>(vec1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// NormalCostructor</span></span><br><span class="line"><span class="comment">// DefaultCostructor</span></span><br><span class="line"><span class="comment">// CopyCostructor</span></span><br><span class="line"><span class="comment">// Move</span></span><br><span class="line"><span class="comment">// Destructor</span></span><br><span class="line"><span class="comment">// Destructor</span></span><br><span class="line"><span class="comment">// Destructor</span></span><br></pre></td></tr></table></figure><p>可以看到，这里不再发生复制，而是转为移动。</p><h3 id="std-move"><a href="#std-move" class="headerlink" title="std::move"></a>std::move</h3><p>C++还为我们提供了一种将值强制转换为右值的方法，这就是<code>std::move</code>，比如下面的例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Vector vec1&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    Vector vec2 = vec1;</span><br><span class="line">    Vector vec3 = std::<span class="built_in">move</span>(vec1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// NormalCostructor</span></span><br><span class="line"><span class="comment">// CopyCostructor</span></span><br><span class="line"><span class="comment">// MoveCostructor</span></span><br><span class="line"><span class="comment">// Destructor</span></span><br><span class="line"><span class="comment">// Destructor</span></span><br><span class="line"><span class="comment">// Destructor</span></span><br></pre></td></tr></table></figure><p><code>vec2</code>使用复制构造函数构造，<code>vec1</code>是一个左值，匹配到复制构造函数。<code>vec3</code>则使用移动构造函数，这里我们使用<code>std::move</code>将<code>vec1</code>强制转换成了右值，使得最后能够匹配到移动构造函数。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++实现Event机制</title>
      <link href="/2023/11/01/C++%E5%AE%9E%E7%8E%B0Event%E6%9C%BA%E5%88%B6/"/>
      <url>/2023/11/01/C++%E5%AE%9E%E7%8E%B0Event%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>最近设计模式的课上讲到了观察者模式，一下子就想到了C#中的委托及事件，因为在Unity项目里经常用到。而用习惯了C#中的事件之后，就觉得课上讲的实现实际使用起来太过麻烦了。</p><p>由于最近在学C++，设计模式课上的作业都是用C++来写的，所以就想到用C++来复刻一下C#中的事件机制。</p><hr><h2 id="C-中的事件"><a href="#C-中的事件" class="headerlink" title="C#中的事件"></a>C#中的事件</h2><p>既然要复刻，那还是先来看看正主是个什么样子。  </p><p>比如说我们要写一个当玩家升级时血量回满并根据等级提升最大生命值的功能，C#实现如下：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HealthPoint</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> CurrentValue &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> MaxValue &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HealthPoint</span>(<span class="params"><span class="built_in">int</span> cv, <span class="built_in">int</span> mv</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        CurrentValue = cv;</span><br><span class="line">        MaxValue = mv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnPlayerLevelUp</span>(<span class="params"><span class="built_in">int</span> pl</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        MaxValue += pl * <span class="number">10</span>;</span><br><span class="line">        CurrentValue = MaxValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Player</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Level &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> HealthPoint Health &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> Action&lt;<span class="built_in">int</span>&gt; LevelUpEvent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Player</span>(<span class="params"><span class="built_in">int</span> cv, <span class="built_in">int</span> mv</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Level = <span class="number">1</span>;</span><br><span class="line">        Health = <span class="keyword">new</span>(cv, mv);</span><br><span class="line">        LevelUpEvent += Health.OnPlayerLevelUp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LevelUp</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Level += <span class="number">1</span>;</span><br><span class="line">        LevelUpEvent?.Invoke(Level);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Player player = <span class="keyword">new</span>(<span class="number">50</span>, <span class="number">100</span>);</span><br><span class="line">Console.WriteLine(<span class="string">&quot;当前血量：&#123;0&#125;，最大血量：&#123;1&#125;&quot;</span>, player.Health.CurrentValue, player.Health.MaxValue);</span><br><span class="line">player.LevelUp();</span><br><span class="line">Console.WriteLine(<span class="string">&quot;当前血量：&#123;0&#125;，最大血量：&#123;1&#125;&quot;</span>, player.Health.CurrentValue, player.Health.MaxValue);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// 当前血量：50，最大血量：100</span></span><br><span class="line"><span class="comment">// 当前血量：120，最大血量：120</span></span><br></pre></td></tr></table></figure><p><code>event Action&lt;int&gt; LevelUpEvent</code>表示<code>LevelUpEvent</code>接受一系列函数类型为<code>void(int)</code>的函数，可以使用<code>+=</code>或<code>-=</code>来添加或删除具有这种类型的对象方法。</p><p>而<code>event</code>限定<code>LevelUpEvent</code>不能被重新赋值，并且只能在定义它的类，也就是<code>Player</code>中调用<code>Invoke</code>方法。</p><h2 id="在C-中的实现"><a href="#在C-中的实现" class="headerlink" title="在C++中的实现"></a>在C++中的实现</h2><p><em><strong>C#中除了<code>Action</code>，还有类似的<code>Func</code>是可以有返回值的，由于这个功能我基本没用过，并且实现上是完全类似的，所以在此我只实现了没有返回值的<code>Action</code>。除此之外限定只能在定义的类内调用<code>Invoke</code>也没能实现。</strong></em></p><h3 id="C-中的可调用对象"><a href="#C-中的可调用对象" class="headerlink" title="C++中的可调用对象"></a>C++中的可调用对象</h3><p>想要统一的调用方法，至少需要这些方法有统一的类型。</p><p>然而在C++中有多种可调用对象，比如下面的这些例子，它们都是返回类型为<code>void</code>接受一个<code>int</code>参数的可调用对象，但实际的类型完全不同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">(<span class="type">int</span>)</span> </span>&#123;&#125; <span class="comment">//普通函数</span></span><br><span class="line"><span class="built_in">void</span> (*Func1)(<span class="type">int</span>) = Func; <span class="comment">//函数指针</span></span><br><span class="line"><span class="keyword">auto</span> Func3 = [](<span class="type">int</span>) &#123;&#125;; <span class="comment">// lambda</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Func4</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span>)</span> </span>&#123;&#125; <span class="comment">// 仿函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Func5</span><span class="params">(<span class="type">int</span>)</span> </span>&#123;&#125; <span class="comment">// 成员函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>好在可以使用<code>std::function</code>（以下简写为<code>function</code>）来将其统一，其中普通函数、函数指针以及lambda表达式都可以直接用于构造<code>function</code>。而仿函数以及成员函数我们可以使用lambda封装后再转换为<code>function</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::function&lt;<span class="title">void</span><span class="params">(<span class="type">int</span>)</span>&gt; <span class="title">f1</span><span class="params">(Func1)</span></span>;</span><br><span class="line"><span class="function">std::function&lt;<span class="title">void</span><span class="params">(<span class="type">int</span>)</span>&gt; <span class="title">f2</span><span class="params">(Func2)</span></span>;</span><br><span class="line"><span class="function">std::function&lt;<span class="title">void</span><span class="params">(<span class="type">int</span>)</span>&gt; <span class="title">f3</span><span class="params">(Func3)</span></span>;</span><br><span class="line"></span><br><span class="line">Func4 func4;</span><br><span class="line">MyClass func5;</span><br><span class="line"><span class="function">std::function&lt;<span class="title">void</span><span class="params">(<span class="type">int</span>)</span>&gt; <span class="title">f4</span><span class="params">([obj = &amp;func4](<span class="type">int</span> a) &#123; obj-&gt;<span class="keyword">operator</span>()(a); &#125;)</span></span>;</span><br><span class="line"><span class="function">std::function&lt;<span class="title">void</span><span class="params">(<span class="type">int</span>)</span>&gt; <span class="title">f5</span><span class="params">([obj = &amp;func5](<span class="type">int</span> a) &#123; obj-&gt;Func5(a); &#125;)</span></span>;</span><br></pre></td></tr></table></figure><p>这样就实现了所有可调用对象的类型统一。</p><h3 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h3><p>为了使语义更加直观，再做一层装饰。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt; <span class="keyword">class</span> <span class="title class_">Listener</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Listener</span>(std::function&lt;<span class="built_in">void</span>(Args...)&gt; handler) : <span class="built_in">m_Handler</span>(std::<span class="built_in">move</span>(handler))</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="built_in">Listener</span>(T *object, <span class="built_in">void</span> (T::*handler)(Args...))</span><br><span class="line">        : <span class="built_in">m_Handler</span>([=](Args &amp;&amp;...args) &#123; (object-&gt;*handler)(std::forward&lt;Args&gt;(args)...); &#125;)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Listener</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Listener</span>(<span class="type">const</span> Listener &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">Listener</span>(Listener &amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Listener &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Listener &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Listener &amp;<span class="keyword">operator</span>=(Listener &amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Handle</span><span class="params">(Args &amp;&amp;...args)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">m_Handler</span>(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    std::function&lt;<span class="type">void</span>(Args...)&gt; m_Handler;</span><br></pre></td></tr></table></figure><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>有了可以响应事件的监听器，接下来就是事件本身了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt; <span class="keyword">class</span> <span class="title class_">Event</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Event</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">Event</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Event</span>(<span class="type">const</span> Event &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">Event</span>(Event &amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Event &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Event &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Event &amp;<span class="keyword">operator</span>=(Event &amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddListener</span><span class="params">(Listener&lt;Args...&gt; *listener)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_Listeners.<span class="built_in">push_back</span>(listener);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">RemoveListener</span><span class="params">(Listener&lt;Args...&gt; *listener)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_Listeners.<span class="built_in">remove</span>(listener);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Invoke</span><span class="params">(Args &amp;&amp;...args)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> l : m_Listeners)</span><br><span class="line">        &#123;</span><br><span class="line">            l-&gt;<span class="built_in">Handle</span>(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    std::list&lt;Listener&lt;Args...&gt; *&gt; m_Listeners;</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">HealthPoint</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> CurrentValue;</span><br><span class="line">    <span class="type">int</span> MaxValue;</span><br><span class="line"></span><br><span class="line">    Listener&lt;<span class="type">int</span>&gt; PlayerLevelUpListener;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">HealthPoint</span>(<span class="type">int</span> cv, <span class="type">int</span> mv)</span><br><span class="line">        : <span class="built_in">CurrentValue</span>(cv), <span class="built_in">MaxValue</span>(mv), <span class="built_in">PlayerLevelUpListener</span>(<span class="keyword">this</span>, &amp;HealthPoint::OnPlayeyLevelUp)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnPlayeyLevelUp</span><span class="params">(<span class="type">int</span> level)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        MaxValue += level * <span class="number">10</span>;</span><br><span class="line">        CurrentValue = MaxValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Player</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> Level&#123;<span class="number">1</span>&#125;;</span><br><span class="line">    HealthPoint Health;</span><br><span class="line">    Event&lt;<span class="type">int</span>&gt; LevelUpEvent&#123;&#125;;</span><br><span class="line">    <span class="built_in">Player</span>(<span class="type">int</span> cv, <span class="type">int</span> mv) : <span class="built_in">Health</span>(cv, mv)</span><br><span class="line">    &#123;</span><br><span class="line">        LevelUpEvent.<span class="built_in">AddListener</span>(&amp;Health.PlayerLevelUpListener);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">LevelUp</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Level += <span class="number">1</span>;</span><br><span class="line">        LevelUpEvent.<span class="built_in">Invoke</span>(Level);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Player <span class="title">player</span><span class="params">(<span class="number">50</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;当前血量：&quot;</span> &lt;&lt; player.Health.CurrentValue &lt;&lt; <span class="string">&quot; 最大血量：&quot;</span> &lt;&lt; player.Health.MaxValue &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    player.<span class="built_in">LevelUp</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;当前血量：&quot;</span> &lt;&lt; player.Health.CurrentValue &lt;&lt; <span class="string">&quot; 最大血量：&quot;</span> &lt;&lt; player.Health.MaxValue &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出</span></span><br><span class="line">    <span class="comment">// 当前血量：50 最大血量：100</span></span><br><span class="line">    <span class="comment">// 当前血量：120 最大血量：120</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>由于C++博大精深，而我所学尚浅，可能目前这个在我看来工作的还算不错的实现实际上有很多错误。但无论是中间某个步骤的完成，还是最终写完整个功能，都让我不自主地兴奋起来。希望能在许多这样的时刻中一直成长下去吧。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>尝试写一下博客</title>
      <link href="/2023/11/01/%E5%BC%80%E5%A7%8B/"/>
      <url>/2023/11/01/%E5%BC%80%E5%A7%8B/</url>
      
        <content type="html"><![CDATA[<p>希望能坚持下去吧。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
